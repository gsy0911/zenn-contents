---
title: "API Platformdで更新処理とかしてみる"
emoji: "🍃"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["php", "symfony", "apiplatform"]
published: false
---

# はじめに

前回、以下の記事を書いてから5ヶ月ほどが経ちました。しばらくAPI Platformを触っていなかったのですが、最近ガッツリと触ってどうやって扱ったらいいかわかってきたので、現時点で理解している内容を記事にします。
https://zenn.dev/gsy0911/articles/ab193f6eba39dc

ドキュメントを見ていても、単一のEntityを扱う場合であったり、複数のEntityでもGETに関する内容はパッと見てもわかるのですが、POSTやPATCHなどの内容はパッとはわからないように書いてあります。そのため、この記事でその辺りをまとめていきます。


## API Platformの印象

本題に入る前にAPI Platformの印象を、触った時期での移り変わりは以下のようになりました。

**触って1時間くらいの印象** 「Entityベースなら扱いやすそうだな〜！FastAPIみたいにAPIのエンドポイントのbodyとかクエリパラメータにクラスを割り当てて行く感じかな〜？ドキュメントとか記事も少ないから不安だけれど、まぁなんとかなるでしょ。」

**触って3日くらいの印象** 「`Groups`の設定の重要さはわかったけれど、Entity周りの更新が扱いづらくない・・・？自由度が低いからやりたいことが全くできないような気がする。Controllerを使うの非推奨って書いてあるけれど、Controller使わないと複雑な操作できなくない・・・？あとやっぱり公式のドキュメントがちょっとわかりづらい、もう少し丁寧にサンプル含めて書いて欲しい。」

**触って2週間くらいの今の印象** 「EasyではにけれどSimpleな作りにはなりそう。最初慣れるのは辛いけれど、運用保守とかは比較的楽になりそう？Symfonyの`Serializer/Deserializer`がかなり重要でそこを理解すれば良さそうだな・・・？以下の図のようなイメージを持てたのでとりあえずはなんとかなるかな？」

API Platformを触っていると、Symfonyの`Serializer/Deserializer`がかなり重要でこれ以外はそこまで重要じゃないという意識を持ちました。API Platformを触る上で下の図のような印象を持ちつつ実装しています。最初見ただけでは以下の図の意味はわからないと思いますが、この記事を最後まで読んでもらえれば理解していただけるかと思います。また、私の理解が間違っていたらその点を指摘していただけると大変ありがたいです。

<!-- Serializer/Deserializerの図、一番複雑な図 -->

## 構成

構成は以下の通りです。最近Symfonyの6.4が出てので使っています。一方でPHPも8.3が出ましたが一旦ここでの利用は見送っています。

- PHP: 8.2
- Symfony: 6.4
- API Platform: 3.2
- MySQL: 8.0

<!-- docker-composeの図 -->

# コード

今回は次のステップで`User`クラスに色々な属性を付与していきます。

1. 基準となる`User`クラスで、GET/POST/PATCHを扱う。ただし、`Groups`で`Serializer/Deserializer`を制御する
2. `User`クラスとManyToOneで紐づく`Prefecture`クラスを考えて、その状態でGET/POST/PATCHを扱う。
3. `User`クラスとManyToManyで紐づく`Book`クラスを考えて、その状態でGET/POST/PATCHを扱う。

<!--- TODO コードが進化していく図、関連の図があると理解ができそう --->

:::message
Deleteメソッドに関しては、まだ把握しきれてない箇所もあるので含めてないです。
:::

# 1. 単純な`User`クラスを考える

前回の記事はBookを対象にしていましたが、今回はUserというクラスから考えていきます。
`Groups`のアトリビュートを設定していますが、あとで説明します。

```php: src/Entity/User.php
<?php

namespace App\Entity;

use ApiPlatform\Metadata\ApiResource;
use ApiPlatform\Metadata\GetCollection;
use ApiPlatform\Metadata\Delete;
use ApiPlatform\Metadata\Get;
use ApiPlatform\Metadata\Patch;
use ApiPlatform\Metadata\Post;
use App\Repository\UserRepository;
use App\State\UserProvider;
use App\State\UserProcessor;
use DateTimeImmutable;
use Doctrine\ORM\Mapping as ORM;
use Gedmo\Mapping\Annotation as Gedmo;
use Symfony\Component\Serializer\Annotation\Groups;
use Symfony\Component\Serializer\Annotation\Context;
use Symfony\Component\Serializer\Normalizer\DateTimeNormalizer;
use Symfony\Component\Validator\Constraints as Assert;

#[ORM\Entity(repositoryClass: UserRepository::class)]
#[ORM\Table(name: 'user', options: ["comment" => '利用者テーブル'])]
#[Gedmo\SoftDeleteable(fieldName: 'deletedAt', timeAware: false)]
#[ApiResource(
    operations: [
        new Get(),
        new GetCollection(),
        new Post(
            normalizationContext: ["groups" => ["user:get"]],
            denormalizationContext: ["groups" => ["user:post"]]
        ),
        new Patch(
            normalizationContext: ["groups" => ["user:get"]],
            denormalizationContext: ["groups" => ["user:patch"]],
            provider: UserProvider::class,
            processor: UserProcessor::class,
        ),
    ],
    normalizationContext: ["groups" => ["user:get"]]
)]
class User
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    #[Groups(groups: ['user:get'])]
    private ?int $id = null;

    #[ORM\Column(length: 255)]
    #[Assert\NotBlank(message: '名前を指定してください')]
    #[Groups(groups: ['user:get', 'user:post', 'user:patch'])]
    private ?string $name = null;

    #[ORM\Column(nullable: true, options: ["comment" => '削除日時'])]
    private ?DateTimeImmutable $deletedAt = null;

    #[Groups(['user:get'])]
    #[ORM\Column(updatable: false, options: [ 'comment' => '作成日時' ])]
    #[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])]
    #[Gedmo\Timestampable(on: 'create')]
    private ?DateTimeImmutable $createdAt = null;

    #[Groups(['user:get'])]
    #[ORM\Column(options: [ 'comment' => '更新日時' ])]
    #[Context([DateTimeNormalizer::FORMAT_KEY => 'Y-m-d'])]
    #[Gedmo\Timestampable(on: 'update')]
    private ?DateTimeImmutable $updatedAt = null;

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getName(): ?string
    {
        return $this->name;
    }

    public function getCreatedAt(): DateTimeImmutable
    {
        return $this->createdAt;
    }

    public function getUpdatedAt(): DateTimeImmutable
    {
        return $this->updatedAt;
    }

    public function setName(string $name): static
    {
        $this->name = $name;
        return $this;
    }
}
```

ほとんど自動生成のコードですが、`UserRepository.php`も一応以下に貼っておきます。

::::details UserRepository.php

```php: src/Repository/UserRepository.php
<?php

namespace App\Repository;

use App\Entity\User;
use Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository;
use Doctrine\Persistence\ManagerRegistry;

/**
 * @extends ServiceEntityRepository<User>
 *
 * @method User|null find($id, $lockMode = null, $lockVersion = null)
 * @method User|null findOneBy(array $criteria, array $orderBy = null)
 * @method User[]    findAll()
 * @method User[]    findBy(array $criteria, array $orderBy = null, $limit = null, $offset = null)
 */
class UserRepository extends ServiceEntityRepository
{
    public function __construct(ManagerRegistry $registry)
    {
        parent::__construct($registry, User::class);
    }

//    /**
//     * @return User[] Returns an array of User objects
//     */
//    public function findByExampleField($value): array
//    {
//        return $this->createQueryBuilder('b')
//            ->andWhere('b.exampleField = :val')
//            ->setParameter('val', $value)
//            ->orderBy('b.id', 'ASC')
//            ->setMaxResults(10)
//            ->getQuery()
//            ->getResult()
//        ;
//    }

//    public function findOneBySomeField($value): ?User
//    {
//        return $this->createQueryBuilder('b')
//            ->andWhere('b.exampleField = :val')
//            ->setParameter('val', $value)
//            ->getQuery()
//            ->getOneOrNullResult()
//        ;
//    }
}
```
::::


## Groupsの設定と役割

一度理解すればそんなに難しくないのですが、最初はこの`Groups`の役割や効果がよくわかりませんでした。[API Platform](https://api-platform.com/docs/core/serialization/)のや[Symfony](https://symfonycasts.com/screencast/api-platform/serializer?cid=apip)に書かれている通りなのですが、、、。

私は、`Groups`のアトリビュートに関して、「Entityから取得するフィールドや更新対象のフィールドを指定するもの」と理解しています。図で表すと以下のようになります。GETの時は`Serializer`の対象となるフィールドを指定して、POSTやPATCHの時はbodyのパラメータからどの値をフィールドに設定する対象とするかを指定します。そして`normalizationContext: ["groups" => ["user:get"]]`や`denormalizationContext: ["groups" => ["user:post"]]`のように指定すれば、特定のメソッドの入出力を制御できるわけです。

<!-- 図 -->

デフォルトでは、クラスの`getter`と`setter`が指定されているフィールドに対しては全てこの`Serializer/Deserializer`が動くため、`#[ApiResource]`というアトリビュートを付与しただけで、動くということも理解できます。最初に触った時は、「あらゆる操作が簡単にできすぎて逆に不便じゃない？」と思いましたが、今は「まぁ処理の流れを考えると普通かな」と思っています。

## `GET /api/users`を考える

Userクラスの`Groups`アトリビュートがついたフィールドのみ抽出すると以下のようになります。

```php: src/Entity/User.php（一部）
    #[Groups(groups: ['user:get'])]
    private ?int $id = null;

    #[Groups(groups: ['user:get', 'user:post', 'user:patch'])]
    private ?string $name = null;

    #[Groups(['user:get'])]
    private ?DateTimeImmutable $createdAt = null;

    #[Groups(['user:get'])]
    private ?DateTimeImmutable $updatedAt = null;
```

また、GETメソッドは次の`normalizationContext`を指定しています。これは、`"user:get"`がついたフィールドのみシリアライズするという意味です。

```php: src/Entity/User.php（一部）
#[ApiResource(
    normalizationContext: ["groups" => ["user:get"]]
)]
```

この状態で、`GET /api/users`を実行すると以下のような結果を得ます。

```json: (response)
{
  "id": "1",
  "name": "Alice",
  "created_at": "2023-12-01",
  "updated_at": "2023-12-01"
}
```

この状態で、例えば「`id`フィールドはレスポンスに含めなくてもいいよね」となった場合に以下のようにすれば、

```diff php: src/Entity/User.php（一部）
-   #[Groups(groups: ['user:get'])]
    private ?int $id = null;

    #[Groups(groups: ['user:get', 'user:post', 'user:patch'])]
    private ?string $name = null;

    #[Groups(['user:get'])]
    private ?DateTimeImmutable $createdAt = null;

    #[Groups(['user:get'])]
    private ?DateTimeImmutable $updatedAt = null;
```

レスポンスには`id`が含まれないようになります。

```json: (response)
{
  "name": "Alice",
  "created_at": "2023-12-01",
  "updated_at": "2023-12-01"
}
```

このようにして、`Groups`と`normalizationContext: ["groups" => ["user:get"]]`でレスポンスの形を制御することができます。

今回は、フィールドの宣言にのみ`Groups`を指定しましたが、`getter/setter`メソッドに指定しても同様のことができます。詳細は以下の公式記事を参照してください。

https://symfonycasts.com/screencast/api-platform/serialization-groups?cid=apip

## `POST /api/users`, `PATCH /api/users`を考える

同じように、`POST /api/users`を考えてみます。この`POST`には`normalizationContext`と`denormalizationContext`を指定しています。`normalizationContext`はGETの時と同じレスポンス時に何を返すかを指定します。`"user:get"`を指定しているので、レスポンスの形はGETと同じという意味です。

POSTやPATCHで重要になってくるのは`denormalizationContext`の方だと思っています。これはリクエストの中に含まれるbodyのどの値をクラスのどのフィールドにsetするか指定できます。

```php: src/Entity/User.php（一部）
        new Post(
            normalizationContext: ["groups" => ["user:get"]],
            denormalizationContext: ["groups" => ["user:post"]]
        ),
```

Userクラスの`Groups`アトリビュートの`"user:post"`がついたフィールドのみ抽出すると以下のようになります。これは、POSTする時には、`name`フィールドのみ送信できることを意味しています。

```php: src/Entity/User.php（一部）
    #[Groups(groups: ['user:get', 'user:post', 'user:patch'])]
    private ?string $name = null;
```

この状態で次のようなbodyを持つPOSTリクエストをすると、レコードが生成されます。

```json: (request-body)
{
  "name": "Alice",
}
```

あまりないかもしれませんが、`"user:post"`を削除すると、`POST /api/users`ではbodyを受け取らなくなります。

```diff php: src/Entity/User.php（一部）
-   #[Groups(groups: ['user:get', 'user:post', 'user:patch'])]
+   #[Groups(groups: ['user:get', 'user:patch'])]
    private ?string $name = null;
```

`PATCH /api/users`に関しても、`POST /api/users`の場合と同じように、`denormalizationContext`が重要なだけなので、説明は割愛します。



## DBの自動更新

少しだけ話は`Serializer/Deserializer`から脱線します。テーブルの作成日時・更新日時・削除日などを自動で更新するために以下のパッケージを追加します。

```shell
$ composer require gedmo/doctrine-extensions
$ composer require stof/doctrine-extensions-bundle
```

追加したら、新規の設定ファイルを追加します。

```yaml: config/packages/stof_doctrine_extensions.yaml
stof_doctrine_extensions:
  default_locale: en_US
  orm:
    default:
      timestampable: true
      softdeleteable: true
```

最後に、以下のファイルに次の行を追記します。

```diff php: app/bundles.php
<?php

return [
+    Stof\DoctrineExtensionsBundle\StofDoctrineExtensionsBundle::class => ['all' => true],
]
```

こうすることで、Entityの作成・更新時に自動的に値を設定してくれます。


# 2. ManyToOneで紐づく`Prefecture`クラスを考える

上記の1の内容は、公式でも十分な資料が提供されていますが、ここからは「ドキュメントから探すのが大変で比較的有益な情報なのでは？」と思っています。とはいえ、ちゃんと公式でも以下のリンクの`Denormalization`の項目で言及はされているのですが・・・。

https://api-platform.com/docs/core/serialization/

## `User`と`Prefecture`クラスの定義

先に`Prefecture`クラスを考えます。単純な`id`と都道府県名を保持する`name`フィールドからなるクラスです。

```php: src/Entity/Prefecture.php
<?php

namespace App\Entity;

use ApiPlatform\Metadata\Get;
use ApiPlatform\Metadata\ApiResource;
use App\Repository\PrefectureRepository;
use Doctrine\ORM\Mapping as ORM;
use Symfony\Component\Serializer\Annotation\Groups;

#[ORM\Entity(repositoryClass: PrefectureRepository::class)]
#[ORM\Table(name: 'prefecture', options: ["comment" => '都道府県テーブル'])]
#[ApiResource(
    operations: [
        new Get(normalizationContext: ["groups" => ["prefecture:get"]]),
    ],
)]
class Prefecture
{
    #[ORM\Id]
    #[ORM\GeneratedValue]
    #[ORM\Column]
    private ?int $id = null;

    #[Groups(groups: ['prefecture:get', "user:get"])]
    #[ORM\Column(length: 8, options: ["comment" => '都道府県名'])]
    private ?string $name = null;

    public function __construct()
    {
    }

    public function getId(): ?int
    {
        return $this->id;
    }

    public function getName(): ?string
    {
        return $this->name;
    }

    public function setName(string $name): static
    {
        $this->name = $name;

        return $this;
    }
}
```

次に`User`クラスに`Prefecture`がManyToOneの関係となるように以下のように追記します。


```diff php: src/Entity/User.php（一部）
class User
{
（中略）
+   #[ORM\ManyToOne]
+   #[Assert\NotBlank(message: '都道府県を選択してください')]
+   #[Groups(groups: ['user:get', "user:post", "user:patch"])]
+   private ?Prefecture $prefecture = null;

（中略）
+   public function getPrefecture(): ?Prefecture
+   {
+       return $this->prefecture;
+   }

+   public function setPrefecture(?Prefecture $prefecture): static
+   {
+       $this->prefecture = $prefecture;
+       return $this;
+   }
}
```

これで、GETやPOST/PATCHを考える準備ができました。

## `GET /api/users`を考える

順番が逆のような気もしますが、GETの方がわかりやすいので先に説明します。DBなどにデータが存在していれば、


## `POST /api/users`, `PATCH /api/users`を考える

# 3. ManyToManyで紐づく`Book`クラスを考える

## `GET /api/users`を考える
## `POST /api/users`, `PATCH /api/users`を考える


# おわりに

