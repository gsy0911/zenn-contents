---
title: "ECS Exec Commandã®æ¨™æº–å‡ºåŠ›ã‚’Pythonã§å–å¾—ã™ã‚‹"
emoji: "ğŸš"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["aws", "ecs"]
published: false
---

# ã¯ã˜ã‚ã«

Lambdaã‹ã‚‰ECS Execã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ã£ã¦ã€å®Ÿè¡Œã—ã¦ã„ã‚‹ã¨ãã«ã†ã¾ãã„ã‹ãªã„æ™‚ãŒã‚ã‚Šã¾ã—ãŸã€‚æ­£ç¢ºãªç†ç”±ã¯ä¸æ˜ãªã®ã§ã™ãŒè‰²ã€…ã¨è©¦ã—ã¦ã„ã‚‹ã¨æ¨™æº–å‡ºåŠ›ã‚’å–å¾—ã—ã¦ã„ãªã„ã“ã¨ãŒåŸå› ã§å¤±æ•—ã—ã¦ã„ã‚‹ã‚ˆã†ã§ã—ãŸã€‚ãã®ãŸã‚ã€ä»¥ä¸‹ã®è¨˜äº‹ã‚’å‚è€ƒã«æ¨™æº–å‡ºåŠ›ã‚’å–å¾—ã—ã¾ã™ã€‚

å‚è€ƒã«ã—ãŸè¨˜äº‹ã ã¨æ¨™æº–å‡ºåŠ›ã®æœ€åˆã®ä¸€éƒ¨ã—ã‹å–å¾—ã§ããªã‹ã£ãŸã®ã§ã€ä¿®æ­£ã—ãŸã‚³ãƒ¼ãƒ‰ã‚’è¼‰ã›ã¦ã„ã¾ã™ã€‚AWSã‚„boto3ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’è¦‹ã¦ã‚‚ã“ã“ã‚‰ä»˜è¿‘ã®è¨˜è¿°ã¯è¦‹ã¤ã‘ã‚‰ã‚Œãªã‹ã£ãŸã®ã§ã€ä»¥ä¸‹ã®è¨˜äº‹ã¯å¤§å¤‰å‚è€ƒã«ãªã‚Šã¾ã—ãŸã€‚

https://blog.father.gedow.net/2022/04/11/aws-ecs-exec-output/

# æº–å‚™

å®Ÿè¡Œã«å¿…è¦ãªä»¥ä¸‹ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¾ã™ã€‚

```shell
$ pip install boto3 websocket-client construct
```

ECS Exec Commandã®æ¨™æº–å‡ºåŠ›ã‚’å–å¾—ã™ã‚‹ã‚¯ãƒ©ã‚¹`EcsExec`ã‚’ä½œæˆãƒ»èª¬æ˜ã—ã¾ã™ã€‚

`get_task_arn()`ã¯æ–°è¦ã«ä½œæˆã—ãŸé–¢æ•°ã§ã€å®Ÿè¡Œä¸­ã®ã‚¯ãƒ©ã‚¹ã‚¿ã®ã‚µãƒ¼ãƒ“ã‚¹ã®ä¸­ã«ã‚ã‚‹ã‚¿ã‚¹ã‚¯ã‚’1ã¤å–å¾—ã™ã‚‹ã‚ˆã†ã«ã—ã¦ã„ã¾ã™ã€‚ã“ã‚Œã¯è¤‡æ•°ã‚¿ã‚¹ã‚¯ãŒç«‹ã¡ä¸ŠãŒã£ã¦ã„ã‚‹ã¨ãã«ã€ä¸€æ„ã«ã‚¿ã‚¹ã‚¯ã‚’å–å¾—ã™ã‚‹ãŸã‚ã«åˆ©ç”¨ã—ã¾ã™ã€‚

`execute_command()`ã¯å‚è€ƒå…ƒã®è¨˜äº‹ã¨ã»ã¨ã‚“ã©å¤‰ã‚ã‚Šã‚ã‚Šã¾ã›ã‚“ã€‚

`get_execute_command_output()`ã¯ã€çµæœã‚’å–å¾—ã™ã‚‹æ–¹æ³•ã‚’å¤§ããå¤‰ãˆã¦ã„ã¾ã™ã€‚å…·ä½“çš„ã«ã¯çµæœã‚’å–å¾—ã™ã‚‹ã”ã¨ã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’`yield`ã™ã‚‹ã“ã¨ã§é€æ¬¡ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã—ã¦ã„ã¾ã™ã€‚ãã®ãŸã‚ã€ã“ã®é–¢æ•°ã‚’å‘¼ã³æ™‚ã¯`for`æ–‡ãªã©ã§å–å¾—ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚

```python
import json
import time
import uuid
from logging import INFO, getLogger
from typing import Generator, Tuple

import boto3
import construct
import websocket

logger = getLogger()
logger.setLevel(INFO)


class EcsExec:
    def __init__(self):
        self.session = boto3.session.Session()
        self.region = self.session.region_name
        self.ecs = boto3.client("ecs", region_name=self.region)

    def get_task_arn(self, cluster: str, service_name: str) -> str:
        tasks = self.ecs.list_tasks(
            cluster=cluster,
            serviceName=service_name,
            desiredStatus="RUNNING",
        )
        return tasks["taskArns"][0]

    def execute_command(self, command, cluster, task_arn, container=None, interactive=True, retry=10):
        params = {
            "cluster": cluster,
            "task": task_arn,
            "command": command,
            "interactive": interactive,
        }
        if container:
            params["container"] = container

        sleep = 5
        for i in range(retry):
            try:
                response = self.ecs.execute_command(**params)
                return response
            except Exception as e:
                if "Wait and try again" in str(e):
                    logger.info(f"Not ready task = {task_arn} in {cluster}")
                    logger.info(f"Try again ... wait {sleep} seconds ...")
                    time.sleep(sleep)
                    continue

                logger.info(f"Failed execute command. task = {task_arn} in {cluster}")
                logger.info(f"Error: {e}")
                return False

        return None

    @staticmethod
    def get_execute_command_output(stream_url: str, token_value: str) -> Generator[Tuple[str, str], None, None]:
        connection = websocket.create_connection(url=stream_url)
        try:
            init_payload = {"MessageSchemaVersion": "1.0", "RequestId": str(uuid.uuid4()), "TokenValue": token_value}
            connection.send(json.dumps(init_payload))

            agent_message_header = construct.Struct(
                "HeaderLength" / construct.Int32ub,
                "MessageType" / construct.PaddedString(32, "ascii"),
            )
            agent_message_payload = construct.Struct(
                "PayloadLength" / construct.Int32ub,
                "Payload" / construct.PaddedString(construct.this.PayloadLength, "ascii"),
            )
            while True:
                response = connection.recv()
                if type(response) is str:
                    yield "channel_closed", ""
                    break

                message = agent_message_header.parse(response)
                logger.info(f"{message.MessageType=}, {message.HeaderLength=}, {message=}")
                if "channel_closed" in message.MessageType:
                    yield "channel_closed", ""
                    break

                if "output_stream_data" in message.MessageType:
                    payload_message = agent_message_payload.parse(response[message.HeaderLength :])
                    yield "output_stream_data", payload_message.Payload
        except websocket.WebSocketTimeoutException as e:
            logger.error(f"{e=}")
            yield "timeout", ""
        finally:
            connection.close()
```


# ä½¿ã„æ–¹

æœ€å¾Œã«ä½¿ã„æ–¹ã‚’èª¬æ˜ã—ã¾ã™ã€‚å‚è€ƒã«ã—ãŸè¨˜äº‹ã‹ã‚‰ã‚ã¾ã‚Šå¤‰ã‚ã£ã¦ã„ã¾ã›ã‚“ãŒã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—ã™ã‚‹ã¨ãã«foræ–‡ã§å–å¾—ã—ã¦ã„ã¾ã™ã€‚

```python
ecs = EcsExec()
# task_arnã‚’ç¨¼åƒä¸­ã®ã‚µãƒ¼ãƒ“ã‚¹ã‹ã‚‰å–å¾—ã™ã‚‹
# ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ãªã©ã‹ã‚‰å–å¾—ã—ã¦ã‚‚å¯
task_arn = ecs.get_task_arn(cluster="...", service_name="...")
# ã‚³ãƒãƒ³ãƒ‰ã‚’å®Ÿè¡Œã™ã‚‹
res = ecs.execute_command(command="ls", cluster="...", container="...", task_arn=task_arn)
logger.info(f"{res=}")

# æ¨™æº–å‡ºåŠ›ã‚’å–å¾—ã™ã‚‹
session = res["session"]
for m in ecs.get_execute_command_output(stream_url=session["streamUrl"], token_value=session["tokenValue"]):
    logger.info(f"{m=}")
```


# ãŠã‚ã‚Šã«

å‚™å¿˜éŒ²çš„ã«ç°¡å˜ã«ã¾ã¨ã‚ã¾ã—ãŸã€‚èª°ã‹ã®å‚è€ƒã«ãªã‚Œã°å¹¸ã„ã§ã™ã€‚
