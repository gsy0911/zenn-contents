---
title: "CDKを使ってNext.jsをS3+CloudFrontの構成にデプロイする"
emoji: "🧀"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["Nextjs", "AWSCDK", "CloudFront"]
published: true
---

# はじめに

CloudFrontを使ってNext.jsなどでビルドされてコンテンツを配信するときに、
S3のアクセス設定を「公開」にしたくない時はないでしょうか？
（S3の公開設定の図を添付）


いくつかの記事でも言及されているように、CloudFront + S3でNext.jsなどのコンテンツを配信する際にはいくつかの方法があります。

1. S3を「静的Webサーバー・全世界に公開」に設定して、CloudFront側では特に気にせずにルーティングする
2. S3の設定は特に変えずに、CloudFrontの前にLambda@Edgeなどでコンテンツへのアクセス部分を変更する

今回は2の方法を採用しつつ、それをCDKで記述できるようにします。
加えて、CloudFrontへ設定を少し加えて、セキュリティも少し意識するようにします。

# やりたいこと・対象読者・構成・料金

## やりたいこと

前述の通りやりたいことは、「CloudFront経由でNext.jsのコンテンツを配信すること」です。
加えて、セキュリティも高めつつ配信されるようにします。

## 対象読者

以下の内容を実行したい人におすすめです。

- CDKを使ってCloudFront + Next.jsの構成を作りたい
- セキュリティも高めつつCloudFrontでの配信を実施したい

## 構成

- 構成図1: Lambda@Edgeの挙動

この構成の理由。

- 構成図2:ResponseHeadersの挙動
  - Overrideとかも気になるので挙動をみてみる

## 料金

今回利用するAWSのサービスは、以下のようになっています。

- Lambda@Edge
- CloudFront
- S3
- Route53
- ACM

# コード

[このリポジトリ](https://github.com/gsy0911/zenn-cloudfront-oai)にコードを載せています。
実際にデプロイする場合は、細かいコードなどはそちらで確認をしてください。
また、本記事でもCloudFrontの部分とLambda@Edgeの挙動に関して少し解説します。

## Lambda@EdgeのコードをJavaScriptで実装する

JavaScriptで作成する場合は、以下のコードのLambda@Edgeを作成すれば実現できます。
この方法は、デプロイ時に手間が少ないため、すぐ実装したい時はこちらをお勧めします。

```javascript:infrastructure/lib/lambda/js_edge/rewrite-trailing-slash/index.js
exports.handler = (event, context, callback) => {
  const request = event.Records[0].cf.request;
  const uri = request.uri;
  // ファイル名 ("/" で区切られたパスの最後) を取得
  const filename = request.uri.split("/").pop();

  if (uri.endsWith("/")) {
    request.uri = request.uri.concat("index.html");
  } else if (filename) {
    if (!filename.includes(".")) {
      // ファイル名に拡張子がついていない場合、 "/index.html" をつける
      request.uri = request.uri.concat("/index.html");
    }
  }
  console.log(`uri: ${uri} -> ${request.uri}`)
  callback(null, request);
}
```

JavaScriptの場合は、以下のCDKのコードでLambda@Edgeを作成することができます。

```typescript:infrastructure/lib/CloudFrontOaiStack.ts
// ~~前略~~

    const dir = path.resolve(__dirname, 'lambda', 'js_edge', 'rewrite-trailing-slash')
    const rewriteTrailingSlashVersion = new aws_cloudfront.experimental.EdgeFunction(this, "edge-origin-request", {
      code: aws_lambda.Code.fromAsset(dir),
      functionName: "origin-request",
      handler: `index.handler`,
      runtime: aws_lambda.Runtime.NODEJS_16_X,
      memorySize: 512,
      timeout: Duration.seconds(5),
      architecture: aws_lambda.Architecture.X86_64,
    })

// ~~後略~~
```

## Lambda@EdgeのコードをTypeScriptで実装する

一方でTypeScriptで作成したい場合は、以下のコードで実現できます。
（当然ながらコードそのものは、JavaScriptとほとんど差はないです。）
ただ、この場合は事前のデプロイが必要になります（詳細は後述）。


```typescript:infrastructure/lib/lambda/ts_edge/rewrite-trailing-slash/index.ts
import {CloudFrontRequestHandler} from "aws-lambda";

export const handler: CloudFrontRequestHandler = async (event) => {
  const request = event.Records[0].cf.request;
  const uri = request.uri;
  // ファイル名 ("/" で区切られたパスの最後) を取得
  const filename = uri.split("/").pop();

  if (uri.endsWith("/")) {
    request.uri = request.uri.concat("index.html");
  } else if (filename) {
    if (!filename.includes(".")) {
      // ファイル名に拡張子がついていない場合、 "/index.html" をつける
      request.uri = request.uri.concat("/index.html");
    }
  }
  return request
}
```

TypeScriptの場合は、以下のCDKのコードでLambda@Edgeを参照しています。
一見、JavaScriptの場合と比べると短く楽に見えますが、
SSMからLambdaのARNを読み取るために、事前に別Stackでデプロイをする必要があります。
デプロイする別Stackの詳細は[この記事](https://zenn.dev/gsy0911/articles/820313c08a545922733f)をご覧ください。

```typescript:infrastructure/lib/CloudFrontOaiStack.ts
// ~~前略~~

    // Lambda@Edge
    const rewriteTrailingSlashParam = aws_ssm.StringParameter.fromStringParameterAttributes(this, 'rewriteTrailingSlashParam', {
      parameterName: `/${prefix}/${params.environment}/${params.lambdaEdgeStackId}/rewriteTrailingSlash`,
    }).stringValue;
    const rewriteTrailingSlashVersion = aws_lambda.Version.fromVersionArn(this, "rewriteTrailingSlashVersion", rewriteTrailingSlashParam)

// ~~後略~~
```

# デプロイ

コードの説明が終わったので、実際にデプロイしてみて挙動を確認してみます。
JavaScriptとTypeScriptとでデプロイの手順が少し異なります。
ここでは、簡単なJavaScriptのみデプロイしてみます。

## 1. NextをビルドしてS3にアップロード

まずは、Nextをビルドします。
ビルドする前に、`trailingSlash: true`を追記します。

```diff javascript:next.config.js
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
+ trailingSlash: true,
}

module.exports = nextConfig
```

`package.json`に以下の変更を追記します。

```diff json:package.json
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
+   "export": "NODE_ENV=production next build && next export -o build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@types/node": "18.11.9",
    "@types/react": "18.0.25",
    "@types/react-dom": "18.0.9",
    "eslint": "8.28.0",
    "eslint-config-next": "13.0.5",
    "next": "13.0.5",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "typescript": "4.9.3"
  }
}
```


それが終わったら、以下のコマンドを実行して`build`ディレクトリにファイルが出力されるようにします。

```shell
# `frontend/`ディレクトリ
$ npm run export
```

nextのファイル出力後に、以下のコマンドでS3にコンテンツをアップロードします。

```shell
# `frontend/`ディレクトリ
$ aws s3 sync build s3://{YOUR_BUCKET_NAME}
```

## 2. Route53などの設定

Route53にドメインを設定して、ACMで証明書を発行しておきます。
必要なのは、Route53のホストゾーンと、CloudFrontに設定したいドメインに対する証明書です。
詳細は[この記事](https://zenn.dev/gsy0911/articles/da47b660b7dd2b7d1ae7#%E6%BA%96%E5%82%99)をご覧ください。


## 3. CDKをデプロイ

Lambda@EdgeがJavaScriptで実装されているStackをデプロイします。
以下のコマンドでデプロイできます。

```shell
# `infrastructure/`ディレクトリ
$ cdk deploy example-cloudfront-oai-js
```

このコマンド1つで`us-east-1`と`ap-northeast-1`の2リージョンにデプロイされます。
そのため、2回デプロイ承認が求められます。

# 挙動の確認

実際にアクセスして確認する。

mdnのサイトにて安全性を確認することを実施する

# おわりに

CDKを使ってNext.jsをS3+CloudFrontの構成にデプロイしました。
この構成を利用する方の参考になれば嬉しいです。

# 参考

