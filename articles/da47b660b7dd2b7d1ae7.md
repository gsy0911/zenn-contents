---
title: "streamlitにcognitoを利用して簡単なログインを作成してみる"
emoji: "🗂"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["AWS", "CDK", "cognito"]
published: false
---

# はじめに

みなさん、`streamlit`は利用されていますか？
`pandas`や`matplotlib`などを利用してデータ可視化する際には便利なツールですよね。

その際に、
「広く公開はしたいけれど、特定の権限などをサクッと付与したいな」と思うことはありませんか？

`streamlit`そのものには認証などの機能はないため、独自に実装したりする必要があります。
そこで今回はAWSでサービスを組むことを想定して、`Cognito`にログイン・認証の機能を持たせてみようと思います。
また、各リソースはCDKでデプロイし、作成と削除を簡単にできるようにしています。

# 料金・構成

## 構成

事前の準備は多少必要ですが、
今回利用するサービスはCDKでデプロイすることを前提としています。

Application LoadBalancerでCognitoの認証を行っています。
Developerはあらかじめ、Cognitoでログイン用のアカウントを作成しておき、
そのアカウントをログインさせたいUserに配布します。
配布されたアカウントのみでCognitoでログインできるようにしているので、
安全にデータを見せつつなどができるようになります。

![](https://storage.googleapis.com/zenn-user-upload/5690cf0cc3d71831b54a0993.png)


## 料金


料金は、利用量にもよって変わるのですが、合計で4,000[円／月]程度かかる計算です。
基本的にアクセスの頻度は低く、Fargateの料金は`0.5vCPU, 256MiB`で計算しています。
サービスごとにかかる料金は以下の通りです。

| AWSサービス | 料金[円／月] |
|:---:|---:|
| Application LoadBalancer | 2,500 |
| Fargate | 1,100 |
| Cognito | （無料） |

# 準備


## Route53

事前に準備が必要な物としてはドメインのみです。
`Route53`に利用するドメインを登録して、すぐに利用できる状態にします。

画像のように、NSタイプとSOAタイプが登録されていたら大丈夫です。
ALBではAタイプを追加して、このドメインにアクセスがあった際にルーティングしてくれるようにします。

![](https://storage.googleapis.com/zenn-user-upload/4744945960113a78bfc5dacb.png)

今回は例として、以下のようにします。

- 取得したルートドメイン： `your.domain.com`
- 今回作成するアプリケーションに設定するサブドメイン： `streamlit.your.domain.com`

画像に設定されているのは、`streamlit.your.domain.com`を想定しています。


## 証明書

あわせて、上記のドメインにhttpsでアクセスできるようにドメインに対して証明書を発行します。
証明書の発行は、どのサブドメインにも適用できる`*.your.domain.com`を入力します。
（下の画像の2つの項目のうち、上の`*.`から始まっている方）

`Route53`を利用している場合は、`your.domain.com`を管理しているホストゾーンに対して
CNAMEタイプのレコードが追加されることになります。

![](https://storage.googleapis.com/zenn-user-upload/c280b887c1f408530813fa8d.png)

# プログラム

プログラムは適宜載せますが、詳細はリポジトリを参照してください。

- [zenn-streamlit-cognito](https://github.com/gsy0911/zenn-streamlit-cognito)

## ディレクトリ構成

ディレクトリ構成は次のようになっています。

`infra/`フォルダにて、CDKのソース管理を行っています。
`streamlit/`フォルダにて、Fargate上で稼働させるアプリケーションをDockerで記述しています。

```shell
root
├── infra/
│  ├── cdk.context.json
│  ├── cdk.json
│  ├── cdk.out
│  ├── index.ts
│  ├── params.ts
│  ├── paramsExample.ts
│  ├── README.md
│  └── StreamlitEcsFargateStack.ts
├── streamlit/
│  ├── app.py
│  ├── config.toml
│  ├── Dockerfile
│  └── Makefile
├── package-lock.json
├── package.json
├── README.md
└── tsconfig.json
```

## ソースコード

streamlitのコード解説はしないです。
CDKで作成されるリソースについてのみちょっと見ていきます。

### Cognitoリソースの作成

Cognitoの設定をしているコードです。
パラメータの詳しい内容は[CDKドキュメント](https://docs.aws.amazon.com/cdk/api/latest/docs/@aws-cdk_aws-cognito.UserPool.html)をご覧ください。

ポイントは以下の2点です。

- `selfSignUpEnabled=false`
    - ユーザーの登録を防いでいる
- `removalPolicy=cdk.RemovalPolicy.DESTROY`
    - このスタックを削除した際に登録内容ごとCognitoを削除するようにしている

```typescript:StreamlitEcsFargateStack.ts
/* ~~前略~~ */

const userPool = new cognito.UserPool(this, "userPool", {
    userPoolName: "streamlit-user-pool-test",
    // self signUp disabled
    selfSignUpEnabled: false,
    userVerification: {
        emailSubject: "Verify email message",
        emailBody: "Thanks for signing up! Your verification code is {####}",
        emailStyle: cognito.VerificationEmailStyle.CODE,
        smsMessage: "Thanks for signing up! Your verification code is {####}"
    },
    // sign in
    signInAliases: {
        username: true,
        email: true
    },
    // user attributes
    standardAttributes: {
        nickname: {
            required: true,
            // `mutable` means changeable
            mutable: true
        }
    },
    // role, specify if you want
    mfa: cognito.Mfa.OPTIONAL,
    mfaSecondFactor: {
        sms: true,
        otp: true
    },
    passwordPolicy: {
        minLength: 8,
        requireLowercase: true,
        requireUppercase: true,
        requireDigits: true,
        requireSymbols: true,
        tempPasswordValidity: cdk.Duration.days(3)
    },
    accountRecovery: cognito.AccountRecovery.EMAIL_ONLY,
    removalPolicy: cdk.RemovalPolicy.DESTROY,
    // emails, by default `no-reply@verificationemail.com` used
})

/* ~~後略~~ */

```

### ALBにCognito認証の付与

ここでは、ALBにCognito認証を設定しています。
ポイントは以下の通りです。

- FargateとALBに設定するセキュリティグループをあえて作成・設定している
    - ALBのセキュリティグループに443のegressを許可するため
- ALBのlistenerにCognitoの認証を加えている
    - 全てのPathPatternに対して認証を加えている

```typescript:StreamlitEcsFargateStack.ts
/* ~~前略~~ */

const ecsServiceSecurityGroup = new ec2.SecurityGroup(this, "ecs-service-sg", {
    vpc,
    securityGroupName: "streamlit-service-sg",
    description: "security group to allow IdP",
})

const service = new ecs.FargateService(this, "StreamlitService", {
    cluster: cluster,
    taskDefinition: taskDef,
    deploymentController: {
        type: ecs.DeploymentControllerType.CODE_DEPLOY
    },
    healthCheckGracePeriod: cdk.Duration.seconds(5),
    assignPublicIp: true,
    securityGroups: [ecsServiceSecurityGroup],
})

// https://<alb-domain>/oauth2/idpresponse
// requires allowing HTTPS egress-rule
const albSecurityGroup = new ec2.SecurityGroup(this, "alb-sg", {
    vpc,
    securityGroupName: "streamlit-alb-sg",
    description: "security group to allow IdP",
    allowAllOutbound: false
})
albSecurityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(80), "allow HTTP")
albSecurityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(8080), "allow alt HTTP")
albSecurityGroup.addIngressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), "allow HTTPS")
albSecurityGroup.addEgressRule(ecsServiceSecurityGroup, ec2.Port.tcp(80), "allow HTTP")
albSecurityGroup.addEgressRule(ec2.Peer.anyIpv4(), ec2.Port.tcp(443), "allow HTTPS")
ecsServiceSecurityGroup.addIngressRule(albSecurityGroup, ec2.Port.tcp(80), "allow from alb-HTTP")

const alb = new elb.ApplicationLoadBalancer(this, "ApplicationLoadBalancer", {
    loadBalancerName: "StreamlitALB",
    vpc: vpc,
    idleTimeout: cdk.Duration.seconds(30),
    // scheme: true to access from external internet
    internetFacing: true,
    securityGroup: albSecurityGroup
})

const listenerHttp1 = alb.addListener("listener-https", {
    protocol: elb.ApplicationProtocol.HTTPS,
    certificates: [elb.ListenerCertificate.fromArn(params.alb.certificate)]
})

const targetGroupBlue = listenerHttp1.addTargets("http-blue-target", {
    targetGroupName: "http-blue-target",
    protocol: elb.ApplicationProtocol.HTTP,
    deregistrationDelay: cdk.Duration.seconds(30),
    targets: [service],
    healthCheck: {
        healthyThresholdCount: 2,
        interval: cdk.Duration.seconds(10)
    },
})
listenerHttp1.addAction("cognito-auth-elb-1", {
    action: new elbActions.AuthenticateCognitoAction({
        userPool: userPool,
        userPoolClient: app1,
        userPoolDomain: userPoolDomain,
        scope: "openid",
        onUnauthenticatedRequest: elb.UnauthenticatedAction.AUTHENTICATE,
        next: elb.ListenerAction.forward([targetGroupBlue])
    }),
    conditions: [elb.ListenerCondition.pathPatterns(["*"])],
    priority: 1
})

/* ~~後略~~ */
```


## デプロイ


# おわりに

